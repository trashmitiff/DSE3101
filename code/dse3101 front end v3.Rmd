---
title: "Public Transport Accessibility Dashboard"
author: 
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(shiny)
library(shinydashboard)
library(sf)
library(leaflet)
library(lubridate)
library(readr)
library(dplyr)
library(ggplot2)
library(plotly)
library(DT)
library(stringr)
library(reticulate)
library(scales)
library(tidyverse)
```

Commuter Hub Density Data
```{r message=FALSE, warning=FALSE}
data_path <- "../data/"
future_com_hub_score <- read_csv(file.path(data_path, "future_com_hub_score_scaled.csv"))
future_combined <- read_csv(file.path(data_path, "final_combined_com_v2.csv"))
final_com_pca <- read_csv(file.path(data_path, "final_combined_com_pca.csv"))
subzone_data <- read_csv(file.path(data_path, "subzone_final.csv"))
subzone_data <- st_as_sf(subzone_data, wkt = "geog_boundary", crs = 4326)

commuter_subzone_data <- subzone_data %>%
  left_join(final_com_pca, by = "subzone_name") %>%
  mutate(relative_commuter_score = round(ifelse(is.na(relative_commuter_score), 0, relative_commuter_score), 3)) %>%
  rename(planning_area_name = planning_area_name.x) %>%
  select(subzone_name, commuter_score, relative_commuter_score, geog_boundary, planning_area_name)

# invalid geometries
commuter_subzone_data <- commuter_subzone_data %>%
  mutate(geog_boundary = st_make_valid(geog_boundary)) %>%
  filter(st_is_valid(geog_boundary))

# average commuter score per planning area (chart)
commuter_planning_area <- commuter_subzone_data %>%
  group_by(planning_area_name) %>%
  summarise(avg_commuter_score = round(mean(relative_commuter_score, na.rm = TRUE), 3)) %>%
  ungroup() %>%
  select(planning_area_name, avg_commuter_score)

# creating a new dataframe to get rid of geog_boundary (table)
commuter_data4table <- commuter_subzone_data %>%
  select(subzone_name, planning_area_name, relative_commuter_score) %>%
  rename(
    "Subzone" = subzone_name,
    "Planning Area" = planning_area_name,
    "Commuter Hub Score" = relative_commuter_score
  ) %>%
  group_by(Subzone, `Planning Area`) %>%
  summarise(`Commuter Hub Score` = round(mean(`Commuter Hub Score`, na.rm = TRUE), 3), .groups = 'drop') %>%
  st_drop_geometry() %>%
  as.data.frame() %>%
  arrange(desc(`Commuter Hub Score`)) 

```

Transport Accessibility Data
```{r}
final_acc_pca = read.csv(file.path(data_path, "final_combined_acc_pca.csv"))
hourly_data = read.csv(file.path(data_path, "hourly_data_pca.csv"))
planning_agg = read.csv(file.path(data_path, "planning_agg.csv"))
raw_acc_values = read.csv(file.path(data_path, "final_combined_acc.csv"))

accessibility_subzone_data <- subzone_data %>%
  left_join(final_acc_pca, by = "subzone_name") %>%
  mutate(acc_score_scaled = round(ifelse(is.na(acc_score_scaled), 0, acc_score_scaled), 3)) %>%
  mutate(acc_score = round(ifelse(is.na(acc_score), 0, acc_score), 3)) %>%
  mutate(bus_acc_score_scaled = round(ifelse(is.na(bus_acc_score_scaled), 0, 
                                             bus_acc_score_scaled), 3)) %>%
  mutate(bus_acc_score = round(ifelse(is.na(bus_acc_score), 0, bus_acc_score), 3)) %>%
  mutate(mrt_acc_score_scaled = round(ifelse(is.na(mrt_acc_score_scaled), 0, 
                                             mrt_acc_score_scaled), 3)) %>%
  mutate(mrt_acc_score = round(ifelse(is.na(mrt_acc_score), 0, mrt_acc_score), 3)) %>%
  rename(planning_area_name = planning_area_name.x) %>%
  select(subzone_name, acc_score, acc_score_scaled, bus_acc_score, 
         bus_acc_score_scaled, mrt_acc_score, mrt_acc_score_scaled, 
         geog_boundary.x, planning_area_name)

# invalid geometries
accessibility_subzone_data <- accessibility_subzone_data %>%
  mutate(geog_boundary.x = st_make_valid(geog_boundary.x)) %>%
  filter(st_is_valid(geog_boundary.x))

# average accessibility score for each transport mode per planning area (chart)
accessibility_planning_area <- accessibility_subzone_data %>%
  group_by(planning_area_name) %>%
  summarise(
    avg_acc_score = round(mean(acc_score_scaled, na.rm = TRUE), 3),
    avg_bus_acc_score = round(mean(bus_acc_score_scaled, na.rm = TRUE), 3),
    avg_mrt_acc_score = round(mean(mrt_acc_score_scaled, na.rm = TRUE), 3),) %>%
  ungroup() %>%
  select(planning_area_name, avg_acc_score, avg_bus_acc_score, avg_mrt_acc_score)

# creating a new dataframe to get rid of geog_boundary (table)
accessibility_data4table <- accessibility_subzone_data %>%
  select(subzone_name, planning_area_name, acc_score_scaled, bus_acc_score_scaled, mrt_acc_score_scaled) %>%
  rename(
    "Subzone" = subzone_name,
    "Planning Area" = planning_area_name,
    "Total Transport Accessibility Score" = acc_score_scaled,
    "Bus Accessibility Score" = bus_acc_score_scaled,
    "MRT Accessibility Score" = mrt_acc_score_scaled
  ) %>%
  group_by(Subzone, `Planning Area`) %>%
  summarise(`Total Transport Accessibility Score` = round(mean(`Total Transport Accessibility Score`, na.rm = TRUE), 3),
            `Bus Accessibility Score` = round(mean(`Bus Accessibility Score`, na.rm = TRUE), 3), 
            `MRT Accessibility Score` = round(mean(`MRT Accessibility Score`, na.rm = TRUE), 3), .groups = 'drop' 
            ) %>%
  st_drop_geometry() %>%
  as.data.frame() %>%
  arrange(desc(`Total Transport Accessibility Score`)) 

```

Commuter Accessibility Ratio
```{r}
# loading data 
future_com_hub_score_unscaled <- read_csv(file.path(data_path, "future_com_hub_score.csv"))
new_coefficient_dict <- read.csv(file.path(data_path, "new_coefficient_dict.csv"))
prenorm_data <- read.csv(file.path(data_path, "prenorm_data.csv"))

# commuter hub score over the next few years by planning area 
future_com_by_planning_area <- future_com_hub_score_unscaled %>%
  group_by(planning_area_name) %>%
  select(c("2025":"2035")) %>%
  summarise_all(mean, na.rm = TRUE) 

# initial stations by planning areas, to use this to calculate when we change user inputs 
initial_stations_sum <- prenorm_data %>% 
  group_by(planning_area_name) %>%
  select(c(area, planning_area_name, total_bus_passengers, 
           total_buses_per_hour, num_bus_stops, num_bus_services, 
           num_stations_per_subzone, num_train_lines_per_subzone, num_rail_types_per_subzone,
           total_train_passengers)) %>%
  summarise_all(sum)
  
initial_stations_mean <- prenorm_data %>% 
  group_by(planning_area_name) %>%
  select(c(priv_to_public_ratio, mean_bus_distance, AM_Peak_Interval, AM_Offpeak_Interval,
           PM_Peak_Interval, PM_Offpeak_Interval, mean_duration_to_train_station, 
           mean_walking_dist_to_train_station, mean_fare_to_train_station)) %>%
  summarise_all(mean)

initial_stations <- initial_stations_sum %>%
  left_join(initial_stations_mean, by = "planning_area_name")

# common columns with PCA coeffcieint dictionary
common_cols <- intersect(names(initial_stations), names(new_coefficient_dict))

# normalise all columns function
get_normalised_df  <- function(df){
  new_df <- df %>% ungroup() %>%
    mutate(across(where(is.numeric), ~ (. - min(., na.rm = TRUE)) / 
                    (max(., na.rm = TRUE) - min(., na.rm = TRUE)))) %>%
    rowwise() %>%
    mutate(new_acc_score = sum(c_across(all_of(common_cols)) * new_coefficient_dict[1, common_cols])) %>%
    ungroup() %>%
    mutate(new_acc_score_scaled = rescale(new_acc_score, to = c(0, 1), na.rm = TRUE)) 
  return(new_df)
}

# normalise the initial 
initial_stations_norm <- get_normalised_df(initial_stations)

# planning area geometries
planning_area_geometry <- subzone_data %>% group_by(planning_area_name) %>% 
  mutate(geog_boundary = st_make_valid(geog_boundary)) %>%
  filter(st_is_valid(geog_boundary)) %>%
  summarize()

# initial accessibility data by planning area
initial_acc_planning <- planning_area_geometry %>%
  left_join(initial_stations_norm, by = "planning_area_name") %>%
  mutate(geog_boundary = st_make_valid(geog_boundary)) %>%
  filter(st_is_valid(geog_boundary))

# get vectors for ui
area_names <- as.vector(initial_stations$planning_area_name)
all_years <- future_com_by_planning_area %>% select(-planning_area_name) %>% colnames()

# function to get new accessibility data with changes made 
# previous df needs to be unscaled !!
get_new_df <- function(previous_df, area_name, 
                       n_bus_per_hour_diff, n_bus_stops_diff, n_bus_services_diff,
                       n_stations_diff, n_lines_diff) {
  
  # new data input calculation
  initial_data <- previous_df %>% filter(planning_area_name == area_name)
  new_bus_per_hour <- max(initial_data$total_buses_per_hour + n_bus_per_hour_diff, 0)
  new_bus_stops <- max(initial_data$num_bus_stops + n_bus_stops_diff, 0)
  new_bus_services <- max(initial_data$num_bus_services + n_bus_services_diff, 0)
  new_mrt <- max(initial_data$num_stations_per_subzone + n_stations_diff, 0)
  new_lines <- max(initial_data$num_train_lines_per_subzone + n_lines_diff, 0)

  # replace data in the dataframe for accessibility calculation
  new_df <- previous_df %>%
    mutate(total_buses_per_hour = 
             ifelse(planning_area_name == area_name, new_bus_per_hour, total_buses_per_hour),
           num_bus_stops = 
             ifelse(planning_area_name == area_name, new_bus_stops, num_bus_stops), 
           num_bus_services = 
             ifelse(planning_area_name == area_name, new_bus_services, num_bus_services), 
           num_stations_per_subzone = 
             ifelse(planning_area_name == area_name, new_mrt, num_stations_per_subzone), 
           num_train_lines_per_subzone = 
             ifelse(planning_area_name == area_name, new_lines, num_train_lines_per_subzone))
  
  return(new_df)
}
# new df is also unscaled!! so after this need to do get_normalised_df()


# duplicate all initial accessibility scores for all years
acc_scores_all_years <- initial_stations_norm %>% 
  select(planning_area_name, new_acc_score) %>%
  bind_cols(
    setNames(
      replicate(length(all_years), .$new_acc_score, simplify = FALSE),
      all_years
    )
  ) %>%
  select(-new_acc_score)

# function to get ratio of commuter-accessibility score
# input needs to be scaled/normalised dataframe, but use unscaled acc score
get_com_acc_ratio <- function(acc_scores_all_years, future_com_by_planning_area) {
  acc_scores_all_years <- acc_scores_all_years %>% arrange(planning_area_name)
  future_com_by_planning_area <- future_com_by_planning_area %>% arrange(planning_area_name)

  # make sure they have common years 
  common_years <- intersect(
    names(acc_scores_all_years)[-1],  # exclude planning area name
    names(future_com_by_planning_area)[-1]
    )

  result <- acc_scores_all_years %>%
    select(planning_area_name) %>%
    bind_cols(
      map_dfc(common_years, ~ {
        future_com_by_planning_area[[.x]] / acc_scores_all_years[[.x]]
        }) %>%
        set_names(paste0(common_years)))
  
  return(result)
}
# higher ratio means got alot of commuters but not accessible enough. should aim for lower ratio 

initial_ratio <- get_com_acc_ratio(acc_scores_all_years, future_com_by_planning_area)


# update accessibility scores for all years
update_acc_scores <- function(acc_scores_all_years, new_norm_df, year) {
  new_scores <- new_norm_df %>% 
    select(planning_area_name, new_acc_score)
  
  year <- as.character(year)
  all_years <- names(acc_scores_all_years)[-1]  # exclude planning area
  years_to_update <- all_years[all_years >= year]

  acc_scores_all_years[years_to_update] <- lapply(
    years_to_update, 
    function(y) new_scores$new_acc_score
  )
  
  return(acc_scores_all_years)
}

# function to combine and make all changes in changes_list
make_all_changes_df <- function(initial_stations, changes_list, acc_scores_all_years,
                                future_com_by_planning_area){
  current_df <- initial_stations
  
  for (change in changes_list) {
    # change params
    area_name <- change$area_name
    year <- change$year
    n_bus_per_hour_diff <- change$n_bus_per_hour_diff
    n_bus_stops_diff <- change$n_bus_stops_diff
    n_bus_services_diff <- change$n_bus_services_diff
    n_stations_diff <- change$n_stations_diff
    n_lines_diff <- change$n_lines_diff
    
    current_df <- get_new_df(current_df, area_name, n_bus_per_hour_diff, n_bus_stops_diff,
                             n_bus_services_diff, n_stations_diff, n_lines_diff)
    current_norm_df <- get_normalised_df(current_df)
    acc_scores_all_years <- update_acc_scores(acc_scores_all_years, current_norm_df, year)
  }
  
  final_ratio <- get_com_acc_ratio(acc_scores_all_years, future_com_by_planning_area)
  
  return (final_ratio)
}

```

UI
```{r}
ui <- dashboardPage(
  dashboardHeader(title = "Public Transport Accessibility"),
  dashboardSidebar(
    sidebarMenu(
      menuItem("Commuter Hub Map", tabName = "commuter_hub", icon = icon("map")),
      menuItem("Transport Accessibility", tabName = "accessibility", icon = icon("bus")),
      menuItem("Simulation Mode", tabName = "simulation", icon = icon("cogs"))
    )
  ),
  dashboardBody(
    tabItems(
      # COMMUTER HUB TAB
      tabItem(tabName = "commuter_hub",
        fluidRow(
          box(title = "Notes", width = 12, status = "info", solidHeader = TRUE,
            p("🧠 Understanding the Commuter Hub Density Score:"),
            tags$ul(
              tags$li("The commuter hub score is derived based on various transport factors including bus and train inflow/outflow volumes. A higher score indicates a location with a high movement of commuters, suggesting it as a major transport hub. The maximum score is 1, and the minimum is 0.")),
            p("📌 How to use this dashboard:"),
            tags$ul(
              tags$li("🗺️ Click on the Map to explore commuter hub density visually."),
              tags$li("🔍 Use the search bar to filter subzones or planning areas of your choice."),
              tags$li("📊 Check the Chart to compare average commuter hub scores.")))),

        fluidRow(
          column(width = 6,
            box(title = "🗺️ Commuter Hub Map", width = NULL, height = "800px",
              leafletOutput("commuter_map", height = "700px")
            )
          ),
          column(width = 6,
            box(title = "📊 Commuter Hub Data", width = NULL, height = "800px",
              tabsetPanel(
                tabPanel("Table", 
                  textInput("subzone_search", "🔍 Search for an Area:", ""),
                  DTOutput("commuter_table"), height = "700px"
                ),
                tabPanel("Chart", 
                  plotlyOutput("commuter_chart", height = "700px"))))))),
            
      # TRANSPORT ACCESSIBILITY TAB
      tabItem(tabName = "accessibility",
        fluidRow(
          box(title = "Notes", width = 12, status = "info", solidHeader = TRUE,
            p("🧠 Understanding the Transport Accessibility Score:"),
            tags$ul(
              tags$li("The transport accessibility score is derived based on various transport factors including number of bus stops and MRT stations in the area, as well as the frequency of buses and trains. A higher score indicates a location that is easy to access with the different modes of public transport. The maximum score is 1, and the minimum is 0.")),
            p("📌 How to use this dashboard:"),
            tags$ul(
              tags$li("🗺️ Select preferred mode of transport and click on the Map to explore transport accessibility visually."),
              tags$li("🔍 Use the search bar to filter subzones or planning areas of your choice."),
              tags$li("📊 Select preferred mode of transport and check the Chart to compare average transport accessibility scores.")))),

        fluidRow(
          column(width = 12,
                 selectInput("transport_mode", "Select Transport Mode:",
                             choices = c("All", "Bus", "MRT")))
        ),
        fluidRow(
          column(width = 6,
            box(title = "🗺️ Transport Accessibility Map", width = NULL, height = "800px",
                leafletOutput("accessibility_map", height = "575px"),
                conditionalPanel(
                  condition = "input.transport_mode == 'All'",
                  sliderInput("time_of_day", "Select Hour of Day:",
                              min = 0, max = 23, value = 12, step = 1)))),

          column(width = 6, 
            box(title = "📊 Transport Accessibility Data", width = NULL, height = "800px",
              tabsetPanel(
                tabPanel("Table",
                  textInput("subzone_search", "🔍 Search for an Area:", ""),
                  DTOutput("accessibility_table"), height = "700px"
                ),
                tabPanel("Chart", 
                  plotlyOutput("accessibility_chart", height = "700px"))))))),
      
      # SIMULATION TAB
      tabItem(tabName = "simulation",
        fluidRow(
          box(title = "Notes", width = 12, status = "info", solidHeader = TRUE,
            p("🧠 Understanding the Commuter-Accessibility Ratios:"),
            tags$ul(
              tags$li("The commuter-accessibility ratios are derived by dividing commuter density scores by transport accessibility scores . If the commuter-accessibility ratio is high, it indicates that an area has lower accessibility with respect to its commuter density. A lower commuter-accessibility ratio is more desirable. You may interact with the dashboard to explore how the commuter-accessibility ratios change over the years, as commuter density is expected to vary with population.")),
            p("📌 How to use this dashboard:"),
            tags$ul(
              tags$li("🗺️ Click on the Map to explore commuter-accessibility ratios visually."),
              tags$li("🔍 Use the search bar to search for planning areas of your choice."),
              tags$li("📊 Check the Chart to compare commuter-accessibility ratios."))
            )),

        fluidRow(
          column(width = 8,
            box(title = "️Commuter-Accessibility Ratios", width = NULL,height="1150px",
              # MAP 
              tabsetPanel(
                tabPanel("🗺 Map", 
                  leafletOutput("sim_map", height = "700px"), 
                  sliderInput("map_slider", 
                              "Select Year:",
                              min = 2025, max = 2035, value = 2025,step = 1,
                              animate = TRUE, sep = "")
                ),
                
                # CHART WITH SLIDING YEAR
                tabPanel("Chart", 
                  plotlyOutput("sim_chart", height = "700px"), ## to change 
                  sliderInput("year_slider", 
                              "Select Year:",
                              min = 2025, max = 2035, value = 2025,step = 1,
                              animate = TRUE, sep = "") 
                ),
                
                # TABLE WITH ALL YEARS
                tabPanel("Table", 
                  textInput("area_search", "🔍 Search for an Area:", ""), 
                  DTOutput("sim_table"), height = "700px" ## to change
                  )
                )
              )
            ),
          column(width = 4,
            box(title = "How to run your own simulation:", width = NULL, 
              tags$p("Select your desired area and year and input your changes for the following:"),
              tags$ul(
                tags$li("Total Buses per hour"),
                tags$li("Total Number of Bus Stops"),
                tags$li("Total Number of Bus Services in the Area"),
                tags$li("Total Number of MRT Stations"),
                tags$li("Total Number of MRT lines")),
              tags$p("Click the 'Add change' button make your changes"),
              tags$p("Curious about each area's transport options? Just click on the map! It’ll help you make better choices when adjusting the simulation."),
            selectInput(
              "year", "Select year",
              choices = all_years,
              selected = all_years[1]
            ),
            selectInput(
              "planning_area", "Select area",
              choices = area_names
            ),
            textInput("busesph", "Input changes to buses per hour", 0),
            textInput("busstops", "Input changes to bus stops", 0),
            textInput("busservices", "Input changes to bus services", 0),
            textInput("mrtstations", "Input changes to MRT stations", 0),
            textInput("mrtlines", "Input changes to MRT lines", 0),
            fluidRow(column(width = 6, actionButton("makechange", "Add change")),
                     column(width = 6, actionButton("clearchanges", "Clear all changes"))),
            DTOutput("changes_table")
            )
          )
        )
      )
    )
  )
)
```

Server
```{r}
server <- function(input, output, session) {
    
  # Commuter Hub Table
  output$commuter_table <- renderDT({
      # when search input is empty, still shows all data
      if (is.null(input$subzone_search) || input$subzone_search == "") {commuter_data4table
      } else {
          commuter_data4table <- commuter_data4table %>%
            filter(
              str_detect(`Subzone`, regex(input$subzone_search, ignore_case = TRUE)) |
              str_detect(`Planning Area`, regex(input$subzone_search, ignore_case = TRUE))
            )
      }
      datatable(commuter_data4table,
                options = list(pageLength = 10,  scrollY = "450px", searching = FALSE), 
                rownames = FALSE, 
                filter = "none")
  })
  
  # Commuter Hub Map
  output$commuter_map <- renderLeaflet({
    leaflet(commuter_subzone_data) %>%
      addTiles() %>%
      addPolygons(
        fillColor = ~colorQuantile("Reds", relative_commuter_score)(relative_commuter_score), 
        fillOpacity = 0.6,
        color = "white",
        weight = 1,
        popup = ~paste0("<b>", subzone_name, "</b><br>Commuter Score: ", relative_commuter_score)
      ) %>%
      addLegend(position = "bottomright",
        colors = c("#B71C1C", "#D32F2F", "#EF5350", "#FFCDD2", "#FFEBEE"),
        labels = c("Very High", "High", "Medium", "Low", "Very Low"),
        title = "Commuter Hub Score",
        opacity = 1
      )
  })
  
  # Commuter Hub Chart
  output$commuter_chart <- renderPlotly({
    com_chart <- ggplot(commuter_planning_area, aes(x = reorder(planning_area_name, avg_commuter_score), 
                                        y = avg_commuter_score, 
                                        fill = avg_commuter_score, 
                                        title = "Commuter Hub Density Score",
                                        text = paste("Planning Area:", planning_area_name, 
                                                     "<br>Score:", round(avg_commuter_score, 2)))) +
      geom_col() +
      scale_fill_distiller(palette = "Reds", direction = 1, name = "Score") +
      coord_flip() +
      labs(x = "Planning Area", y = "Average Commuter Score", title = "Average Commuter Score by Planning Area") +
      theme_minimal() +
      theme(legend.position = "right",
            axis.text = element_text(size = 7),
            axis.title = element_text(size = 10),
            plot.title = element_text(size = 12, face = "bold"))
    
    ggplotly(com_chart, tooltip = "text")
  })
  
  
  # Transport Accessibility Table
  output$accessibility_table <- renderDT({
    if (input$transport_mode == "All") {
      accessibility_data4table <- accessibility_data4table %>%
        select(`Subzone`, `Planning Area`, `Total Transport Accessibility Score`)
    } else if (input$transport_mode == "Bus") {
      accessibility_data4table <- accessibility_data4table %>%
        select(`Subzone`, `Planning Area`, `Bus Accessibility Score`)
    } else {
      accessibility_data4table <- accessibility_data4table %>%
        select(`Subzone`, `Planning Area`, `MRT Accessibility Score`)
    }
        
      # when search input is empty, still shows all data
      if (is.null(input$subzone_search) || input$subzone_search == "") {accessibility_data4table
      } else {
          accessibility_data4table <- accessibility_data4table %>%
            filter(
              str_detect(`Subzone`, regex(input$subzone_search, ignore_case = TRUE)) |
              str_detect(`Planning Area`, regex(input$subzone_search, ignore_case = TRUE))
            )
      }
      datatable(accessibility_data4table,
                options = list(pageLength = 10, scrollY = "450px",searching = FALSE), 
                rownames = FALSE, 
                filter = "none")
  })  

  # Transport Accessibility Map
  output$accessibility_map <- renderLeaflet({
    
    if (input$transport_mode == "All") {
      
      hour_data <- hourly_data %>%
        filter(hour == input$time_of_day) %>%
        mutate(hourly_acc_score_scaled = round(acc_score_scaled, 3)) %>%
        select(subzone_name, hourly_acc_score_scaled)
      
      accessibility_map_data <- accessibility_subzone_data %>% 
        left_join(hour_data, by = "subzone_name") %>%
        left_join(raw_acc_values, by = "subzone_name") %>%
        mutate(accessibility_score = ifelse(is.na(hourly_acc_score_scaled), 0, hourly_acc_score_scaled))
      
      if (input$time_of_day >= 1 & input$time_of_day <= 4) {
        color_scale <- colorBin(
          palette = "Reds",
          domain = c(0, 1),
          bins = c(seq(0, 0.01, by = 0.002), 0.02, 1))
      } else {
        color_scale <- colorQuantile(
          palette = "Reds",
          domain = accessibility_map_data$accessibility_score,
          n = 5)
      }
      
      leaflet(accessibility_map_data) %>%
      addTiles() %>%
      addPolygons(
        fillColor = ~color_scale(accessibility_score), 
        fillOpacity = 0.9,
        color = "white",
        weight = 1,
        popup = ~paste0(
          "<b>", subzone_name, "</b><br>",
          "Accessibility Score: ", accessibility_score, "<br>",
          "No. of Bus Stops: ", round(num_bus_stops, 0), "<br>",
          "No. of Bus Services: ", round(num_bus_services, 0), "<br>",
          "No. of Train Stations: ", round(num_stations_per_subzone, 0), "<br>",
          "No. of Train Lines: ", round(num_train_lines_per_subzone, 0))
      ) %>%
      addLegend(position = "bottomright",
        colors = c("#B71C1C", "#D32F2F", "#EF5350", "#FFCDD2", "#FFEBEE"),
        labels = c("Very High", "High", "Medium", "Low", "Very Low"),
        title = "Accessibility Score",
        opacity = 1)
    } else if (input$transport_mode == "Bus") {
      bus_data <- raw_acc_values %>%
        select(subzone_name, num_bus_stops, num_bus_services)
      
      accessibility_map_data <- accessibility_subzone_data %>%
        left_join(bus_data, by = "subzone_name") %>%
        mutate(accessibility_score = ifelse(is.na(bus_acc_score_scaled), 0, bus_acc_score_scaled))
      
      pal <- colorBin(
        palette = rev("Greens"),
        domain = accessibility_map_data$accessibility_score,
        bins = rev(c(0, 0.05, 0.1, 0.15, 0.2, 0.4, 0.6, 0.8, 1)))
      
      leaflet(accessibility_map_data) %>%
        addTiles() %>%
        addPolygons(
          fillColor = ~pal(accessibility_score),
          fillOpacity = 0.9,
          color = "white", 
          weight = 1,
          popup = ~paste0("<b>", subzone_name, "</b><br>",
                          "Accessibility Score: ", accessibility_score, "<br>",
                          "No. of Bus Stops: ", round(num_bus_stops, 0), "<br>",
                          "No. of Bus Services: ", round(num_bus_services, 0))) %>%
        addLegend(position = "bottomright",
                  pal = pal,
                  values = ~accessibility_score,
                  title = "Accessibility Score",
                  opacity = 1)
    } else {
      mrt_data <- raw_acc_values %>%
        select(subzone_name, num_stations_per_subzone, num_train_lines_per_subzone)
      
      accessibility_map_data <- accessibility_subzone_data %>%
        left_join(mrt_data, by = "subzone_name") %>%
        mutate(accessibility_score = ifelse(is.na(mrt_acc_score_scaled), 0, mrt_acc_score_scaled))
      
      pal <- colorBin(
        palette = rev("Blues"),
        domain = accessibility_map_data$accessibility_score,
        bins = rev(c(0, 0.02, 0.04, 0.06, 0.08, 0.1, 0.2, 0.4, 1)))
      
      leaflet(accessibility_map_data) %>%
        addTiles() %>%
        addPolygons(
          fillColor = ~pal(accessibility_score),
          fillOpacity = 0.9,
          color = "white", 
          weight = 1,
          popup = ~paste0("<b>", subzone_name, "</b><br>",
                          "Accessibility Score: ", accessibility_score, "<br>",
                          "No. of Train Stations: ", round(num_stations_per_subzone, 0), "<br>",
                          "No. of Train Lines: ", round(num_train_lines_per_subzone, 0))) %>%
        addLegend(position = "bottomright",
                  pal = pal,
                  values = ~accessibility_score,
                  title = "Accessibility Score",
                  opacity = 1)
    }
  })
  
  
  # Transport Accessibility Chart
  output$accessibility_chart <- renderPlotly({
    selected_score <- ifelse(input$transport_mode == "All", "avg_acc_score", ifelse(input$transport_mode == "Bus", "avg_bus_acc_score", "avg_mrt_acc_score"))
    acc_chart <- ggplot(accessibility_planning_area, aes(x = reorder(planning_area_name, get(selected_score)),
                                                         y = get(selected_score),
                                                         fill = get(selected_score),
                                                         text = paste("Planning Area:", planning_area_name,
                                                                      "<br>Score:", round(get(selected_score), 2)))) +
      geom_col() +
      scale_fill_distiller(palette = ifelse(selected_score == "avg_acc_score", "Reds", 
                                            ifelse(selected_score == "avg_bus_acc_score", "Greens", "Blues")), direction = 1, name = "Score") + 
      coord_flip() +
      labs(x = "Planning Area",
           y = "Average Accessibility Score", 
           title = paste("Average",
                         switch(selected_score, 
                                "avg_acc_score" = NULL,
                                "avg_bus_acc_score" = "Bus",
                                "avg_mrt_acc_score" = "MRT"),
                         "Accessibility Score by Planning Area")) +
      theme_minimal() +
      theme(legend.position = "right",
            axis.text = element_text(size = 7),
            axis.title = element_text(size = 10),
            plot.title = element_text(size = 12, face = "bold"))
    ggplotly(acc_chart, tooltip = "text")
  })
  
  #SIMULATION NEEDS
  changes <- reactiveVal(list())
  
  final_ratio <- reactive({
    current_changes <- changes()
    if (length(current_changes) > 0) {
      changes_data <- lapply(current_changes, function(x) {
        x[c("area_name", "year", "n_bus_per_hour_diff", 
            "n_bus_stops_diff", "n_bus_services_diff",
            "n_stations_diff", "n_lines_diff")]})
      make_all_changes_df(initial_stations, changes_data, acc_scores_all_years, future_com_by_planning_area)
    } else {initial_ratio}})
  
  # EVENT MAKE CHANGE
  observeEvent(input$makechange, {
    req(input$planning_area, input$year, input$busesph, input$busstops, 
        input$busservices, input$mrtstations, input$mrtlines)

    new_change <- list(
      area_name = as.character(input$planning_area),
      year = as.character(input$year),
      n_bus_per_hour_diff = as.numeric(input$busesph),
      n_bus_stops_diff = as.numeric(input$busstops),
      n_bus_services_diff = as.numeric(input$busservices),
      n_stations_diff = as.numeric(input$mrtstations),
      n_lines_diff = as.numeric(input$mrtlines)
    )
  
    isolate({
      current_changes <- changes()
      changes(c(current_changes, list(new_change)))})
    
    sapply(c("busesph", "busstops", "busservices", "mrtstations", "mrtlines"),
         function(x) updateTextInput(session, x, value = "0"))})
  
  
  # EVENT CLEAR CHANGES
  observeEvent(input$clearchanges, {changes(list())})
  
  # CHANGES TABLE 
  output$changes_table <- renderDT({
    req(length(changes()) > 0)
  
    changes_df <- data.frame(
      Area = sapply(changes(), function(x) x$area_name),
      Year = sapply(changes(), function(x) x$year),
      `Bus/Hour` = sapply(changes(), function(x) x$n_bus_per_hour_diff),
      `Bus Stops` = sapply(changes(), function(x) x$n_bus_stops_diff),
      `Bus Services` = sapply(changes(), function(x) x$n_bus_services_diff),
      `MRT Stations` = sapply(changes(), function(x) x$n_stations_diff),
      `MRT Lines` = sapply(changes(), function(x) x$n_lines_diff),
      Remove = sapply(1:length(changes()), function(i) {
        as.character(actionButton(
          paste0("delete_", i),
          label = "X",
          onclick = paste0('Shiny.setInputValue("delete_row", ', i, ')'),
          class = "btn-danger btn-sm"
        ))
      }),
      check.names = FALSE
    )

    datatable(
      changes_df, escape = FALSE, rownames = FALSE,
      options = list(scrollX = TRUE, scrollY = "200px", paging = FALSE, dom = 't',autoWidth = TRUE,
        columnDefs = list(list(targets = "_all", className = "dt-center"))
      )
    )
  })
  
  # EVENT DELETE ROW 
  observeEvent(input$delete_row, {
    req(input$delete_row)
    changes(changes()[-input$delete_row])
  })
  
  # SIMULATION MAP
  current_df <- reactive({
    planning_area_geometry %>% 
      left_join(final_ratio(), by = "planning_area_name")
  })
  
  selected_year <- reactive({
    req(input$map_slider)  
    as.character(input$map_slider)
  })
  
  pal <- reactive({
    req(current_df(), selected_year())
    colorNumeric("RdYlGn", domain = current_df()[[selected_year()]], reverse = TRUE, na.color = "gray")
    })
  
  output$sim_map <- renderLeaflet({
    req(current_df(), selected_year(), pal())
    
    current_year <- selected_year()
    df <- current_df()
    df <- df %>% left_join(initial_stations, by = "planning_area_name")
    
    leaflet(df) %>%
      addTiles() %>%
      addPolygons(
        fillColor = ~pal()(df[[current_year]]), 
        fillOpacity = 0.7,
        color = "white",
        weight = 1,
        popup = ~paste0("<b>", planning_area_name, 
                       "</b><br>Commuter-Accessibility Ratio: ", round(df[[current_year]], 2), 
                       "</b><br>2025 Number of Buses/Hour: ", round(total_buses_per_hour), 
                       "</b><br>2025 Number of Bus Stops: ", num_bus_stops, 
                       "</b><br>2025 Number of Bus Services: ", round(num_bus_services), 
                       "</b><br>2025 Number of MRT Stations: ", num_stations_per_subzone, 
                       "</b><br>2025 Number of MRT Lines: ", round(num_train_lines_per_subzone))
      ) %>%
      addLegend(
        position = "bottomright",
        pal = pal(), 
        values = na.omit(df[[current_year]]), 
        title = "Commuter-Accessibility Ratio",
        opacity = 1
      )
  })

  # SIMULATION CHART
  output$sim_chart <- renderPlotly({
    req(input$year_slider, current_df())
    
    year_col <- as.character(input$year_slider)
    df <- current_df()
    
    plot_data <- df %>%
      arrange(-is.na(.data[[year_col]]), .data[[year_col]]) %>%
      mutate(planning_area_name = factor(planning_area_name, levels = unique(planning_area_name)))
    
    p <- ggplot(plot_data, 
           aes(x = planning_area_name,
               y = .data[[year_col]], 
               fill = .data[[year_col]],
               text = paste("Planning Area:", planning_area_name,
                           "<br>Commuter-Accessibility Ratio:", round(.data[[year_col]], 2)))) +
      geom_col() +
      scale_fill_distiller(palette = "RdYlGn", direction = -1) +
      coord_flip() +
      labs(x = "Planning Area", 
           y = "Commuter-Accessibility Ratio", 
           title = paste("Accessibility Ratio (", input$year_slider, ")")) +
      theme_minimal() +
      theme(axis.text.y = element_text(size = 7))
    
    ggplotly(p, tooltip = "text") 
  })
  
  # SIMULATION TABLE
  output$sim_table <- renderDT({
    req(current_df())
    
    table_data <- current_df() %>% 
      st_drop_geometry() %>%
      mutate(across(where(is.numeric), \(x) round(x, digits = 3)))
    
    if (!is.null(input$area_search) && input$area_search != "") {
      table_data <- table_data %>%
        filter(str_detect(planning_area_name, regex(input$area_search, ignore_case = TRUE)))
    }
    
    datatable(
      table_data, extensions = 'FixedColumns', rownames = FALSE,
      options = list(
        pageLength = 25,
        searching = FALSE,
        scrollX = TRUE, scrollY = "800px",
        fixedColumns = list(leftColumns = 1)
      )
    )
  })
}
```


```{r}
shinyApp(ui, server)
```

